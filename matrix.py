import numpy as np
# 3d matrix generated by using random numbers
n = 30
m = 10
p = 5
matrix = np.random.randint(-100, 100, size=(n, m, p))

# similar to flatten function in numpy
def flatten_3d_matrix(matrix, n, m, p):
    q = n * m * p 
    vector_1d = [0]*q
    idx=0
    for i in matrix:
        for j in i:
            for k in j:
                vector_1d[idx] = k
                idx += 1
    return np.array(vector_1d), q


vector, q = flatten_3d_matrix(matrix, n, m, p)
def map_3d_to_1d(m, p, i, j, k):
    # first : choose the proper matrix by skipping all the elements of the unwanted m*p
    # second : choose the proper row by skipping all elements of the unwanted p
    # third : add offset of the column element needed
    y = (i * m * p) + (j * p) + k
    return y

i, j, k = 1, 2, 1
print('matrix val: ', matrix[i][j][k])
print('vector val: ', vector[map_3d_to_1d(m, p, i, j, k)])


